Architecture for an 8 bit general purpose cpu

======================================================================
NOTES
======================================================================

Notation H|L refers to concatenation, H being high and L being low; for example: 1|2 = 12, 0xAB|0xCD = 0xABCD

======================================================================
FEATURES
======================================================================

8 bit value bus
16 bit address bus
2 "controller" inputs
a 256x192 screen buffer that outputs to a 1024x768 vga monitor

======================================================================
REGISTERS
======================================================================

8 bit general purpose registers:

rga - general purpose register a
rgb - general purpose register b
rgc - general purpose register c
rgd - general purpose register d


16 bit usable registers - accessible by replacing the 'x' with 'h' or 'l' for accessing the low:

rmx - memory access
rsx - stack top pointer
rbx - stack base pointer
rpx - 16 bit program counter

Reserved (non usable) registers:

rgi - 24 bit instruction register

rgf - flags register (bitwise, low to high)

    0 flag
    carry
    negative/borrow
    BCD adjust

int - interrupt mask register (bitwise, low to high)

    external sources 0-5
    unused
    global interrupt disable


======================================================================
INSTRUCTION SET
======================================================================

instruction name    | opcode    | description
                    |           |
nop                 | 0x0       | no operation
mov                 | 0x1       | move a value from the right operand into the left operand
spc                 | 0x2       | special instructions - used port interaction
jfg                 | 0x3       | conditional jump with flags. jumps to the inputted memory location if "( rgf OR inp ) == 0xF", where "inp" is a 4bit value. use like jxx <label/memory address>
inc                 | 0x4       | increment the selected operand
dec                 | 0x5       | decrement the selected operand
not                 | 0x6       | bitwise not on the selected operand
rot                 | 0x7       | bitwise rotate the selected operand
and                 | 0x8       | bitwise and. saves result into the left operand
or                  | 0x9       | bitwise or. saves result into the left operand
adc                 | 0xA       | add with carry. saves result into the left operand 
sbb                 | 0xB       | subtract with borrow. saves result into the left operand
mul                 | 0xC       | multiply rga by rgb. saves result into rga and rgb using rgb as the high byte and rga as the low byte
div                 | 0xD       | divide rga by rgb. saves result into rga, and remainder into rgb
mov16               | 0xE       | move a value from the right operand into the left operand, both operands being one of the 4 16bit registers
add16               | 0xF       | add a specific 16 bit register by an 8bit immediate

C/Verilog explanations:
for any op[7:0],op1[7:0],op2[7:0]

nop     | nothing
mov     | op1 = op2
spc     | depends, see below
jfg     | if(inp | rgf) goto <location>
inc     | op++
dec     | op--
not     | op = ~op
rot     | op = {op[0],op[7:1]}
and     | op1 &= op2
or      | op1 |= op2
adc     | op1 += op2
sbb     | op1 -= op2

spc instructions meaning:
    0x0 : read port 0
    0x1 : write to port 0
    0x2 : read port 1
    0x3 : write to port 1
    ...
    0xA : read port 5
    0xB : write to port 5

    0xC,0xD : reserved for future use
    
    0xE : unset the high bits from the interrupt mask
    0xF : set the high bits from the interrupt mask

------ details in instructions.xslx ------ 

======================================================================
INSTRUCTION FORMAT
======================================================================

instruction formatting for opcodes 0x1, 0x8 - 0xB:

byte 0: <4 bit opcode><2 bit info on left operand><2 bit info on right operand>
byte 1: <4 bit info on left operand><4 bit info on right operand>
byte 2: <situational 8 bit immediate>

instruction formatting for opcodes 0x4 - 0x6:
byte 0: <4bit opcode><4bit info on the operand>

encoding of the 2bit info:
    0b00 - none | reserved
    0b01 - register | requires 4bit info on it's respective byte
    0b10 - memory access | requires 4 bit info on which 16bit register to use to access memory. valid as left operand only in the mov operation
    0b11 - 8 bit immediate | only valid as the second operand in a binary operation

encoding of the detailed 4bit info:

if register:
    0x4 - rga
    0x5 - rgb
    0x6 - rgc
    0x7 - rgd

    0x8 - rmh
    0x9 - rml
    0xA - rsh
    0xB - rsl
    0xC - rbh
    0xD - rbl
    0xE - rph
    0xF - rpl

if memory access:
    0x0 - rmx
    0x1 - rsx
    0x2 - rbx
    0x3 - rcx

instruction formatting for opcodes 0xC, 0xD:
byte 0: <4bit opcode><4 unused bits>

mov16 instruction formatting:
byte 0: <4 bit opcode><2 bit info on left operand><2 bit info on right operand>

add16 instruction formatting:
byte 0: <4 bit opcode><2 bit info on left operand><2 unused bits>
byte 1: <8bit immediate>

encoding of the 2bit info:
    0b00 - rmx
    0b01 - rsx
    0b10 - rbx
    0b11 - rpx


spc instruction format:

spc 0x0 - 0xB:
byte 0: <spc instruction code>
byte 1: <8bit read/write mask immediate>



======================================================================
ROM LAYOUT
======================================================================

0x0000 - 0x007F : startup sector - the cpu starts executing indiscriminately from address 0
0x0080 - 0x00EF : reserved for future use
0x00F0 - 0x00FF : interrupt table (2 bytes / interrupt source)
everything else : instruction, heap, stack memory

the CPU needs some sort of bootloader to put everything from rom into memory


======================================================================
MEMORY LAYOUT
======================================================================

same as ROM.
stack starts at 0xFFFF and grows down.


Note that all memory can be accessed and modified, but obviously it is dangerous.

All memory allocation should be done via the compiler, and notify the programmer if any free pointers used get in any of the reserved areas.