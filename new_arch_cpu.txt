Architecture for an 8 bit general purpose cpu

======================================================================
NOTES
======================================================================

Notation H|L refers to concatenation, H being high and L being low; for example: 1|2 = 12, 0xAB|0xCD = 0xABCD

======================================================================
FEATURES
======================================================================

8 bit value bus
16 bit address bounds
4 general purpose RW ports
4 interrupt sources

======================================================================
REGISTERS
======================================================================

8 bit general purpose registers:

rga - general purpose register a
rgb - general purpose register b
rgc - general purpose register c
rgd - general purpose register d


16 bit usable registers - accessible by replacing the 'x' with 'h' or 'l' for accessing the high or low byte respectively:

rmx - general memory access
rsx - stack top pointer
rbx - stack base pointer
rpx - program counter

Reserved (non usable) registers:

rgi - 24 bit instruction register

rgf - flags register (bitwise, low to high)

    0 flag
    carry
    sign change
    unused (negation in conditions, always 1)

int - interrupt mask register (bitwise, low to high)

    external sources 0-3
    unused x3
    global interrupt disable

rcd - 8 bit call depth register. breaks at overflow/underflow (too many subroutine calls or a ret instruction is executed without a paired call)

cpr - stack call info register array - 256 x 32 bit


======================================================================
INSTRUCTION SET
======================================================================

instruction name    | opcode    | description
                    |           |
nop                 | 0x0       | no operation
mov                 | 0x1       | move a value from the right operand into the left operand
spc                 | 0x2       | special instructions - used for port interaction
jfg                 | 0x3       | conditional jump with flags. jumps to the inputted memory location if "( rgf OR inp ) == 0xF", where "inp" is a 4bit value. use like jxx <label/memory address>
inc                 | 0x4       | increment the selected operand
dec                 | 0x5       | decrement the selected operand
rot                 | 0x6       | bitwise rotate the selected operand
nor                 | 0x7       | bitwise nor on the selected operand
and                 | 0x8       | bitwise and. saves result into the left operand
adc                 | 0x9       | add with carry. saves result into the left operand 
mul                 | 0xA       | multiply rga by rgb. saves result into rga and rgb using rgb as the high byte and rga as the low byte
div                 | 0xB       | divide rga by rgb. saves result into rga, and remainder into rgb
ccs                 | 0xC       | conditional call to subroutine. conditions work exactly like for jfg
ret                 | 0xD       | return from subroutine
mov16               | 0xE       | move a value from the right operand into the left operand, both operands being one of the 4 16bit registers
add16               | 0xF       | add a specific 16 bit register by an 8bit immediate

C/Verilog explanations:
for any op[7:0],op1[7:0],op2[7:0]

nop     | nothing
mov     | op1 = op2
spc     | depends, see below
jfg     | if(inp | rgf) goto <location>
inc     | op++
dec     | op--
rot     | op1 = {op1[op2 & 7:0],op1[7:op2&7+1]}
and     | op1 &= op2
nor     | op1 = ~(op1 | op2)
adc     | op1 += op2
sbb     | op1 -= op2

spc instructions meaning:
    0x0 : read port 0
    0x1 : write to port 0
    0x2 : read port 1
    0x3 : write to port 1
    ...
    0x6 : read port 3
    0x7 : write to port 3

    0x8-0xD : reserved for future use
    
    0xE : unset the high bits from the interrupt mask
    0xF : set the high bits from the interrupt mask

------ details in instructions.xslx ------ 

======================================================================
INSTRUCTION FORMAT
======================================================================

instruction formatting for opcodes 0x1, 0x8 - 0xB:

byte 0: <4 bit opcode><2 bit info on left operand><2 bit info on right operand>
byte 1: <4 bit info on left operand><4 bit info on right operand>
byte 2: <situational 8 bit immediate>

instruction formatting for opcodes 0x4 - 0x6:
byte 0: <4 bit opcode><4 bit info on the operand>

instruction formatting for opcde 0x7:
byte 0: <4 bit opcode><4 bit info on the operand>
byte 1: <8 bit immediate>


encoding of the 2bit info:
    0b00 - none | reserved
    0b01 - register | requires 4bit info on it's respective byte
    0b10 - memory access | requires 4 bit info on which 16bit register to use to access memory. valid as left operand only in the mov operation
    0b11 - 8 bit immediate | only valid as the second operand in a binary operation

encoding of the detailed 4bit info:

if register:
    0x4 - rga
    0x5 - rgb
    0x6 - rgc
    0x7 - rgd

    0x8 - rmh
    0x9 - rml
    0xA - rsh
    0xB - rsl
    0xC - rbh
    0xD - rbl
    0xE - rph
    0xF - rpl

if memory access:
    0x0 - rmx
    0x1 - rsx
    0x2 - rbx
    0x3 - rpx

instruction formatting for opcodes 0xC, 0xD (mul, div):
byte 0: <4bit opcode><4 unused bits>

mov16 instruction formatting:
byte 0: <4 bit opcode><2 bit info on left operand><2 bit info on right operand>

add16 instruction formatting:
byte 0: <4 bit opcode><2 bit info on left operand><2 unused bits>
byte 1: <8bit immediate>

encoding of the 2bit info:
    0b00 - rmx
    0b01 - rsx
    0b10 - rbx
    0b11 - rpx


spc instruction format:

spc 0x0 - 0x7:
byte 0: <spc instruction code>
byte 1: <8bit read/write mask immediate>

jump format:

jfg _flag _label:
if _flag <  8:
    jump to _label if ( rgf | _flag == 0b1111) 
if _flag >= 8:
    jump to _label if (~rgf | _flag == 0b1111) 


======================================================================
ROM LAYOUT
======================================================================

0x0000 - 0x007F : startup sector - the cpu starts executing indiscriminately from address 0
0x0080 - 0x00EF : reserved for future use
0x00F0 - 0x00FF : interrupt table (2 bytes / interrupt source)
everything else : instruction, heap, stack memory

the CPU needs some sort of bootloader to put everything from rom into memory


======================================================================
MEMORY LAYOUT
======================================================================

same as ROM.
stack starts at 0xFFFF and grows down.


Note that all memory can be accessed and modified, but obviously it is dangerous.

All memory allocation should be done via the compiler, and notify the programmer if any free pointers used get in any of the reserved areas.